# volatile
##### 原子性
即一个操作或者多个操作，要么全部执行，并且执行的过程不回被任何因素打断，要么就都不执行
Java中的原子性：对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作时不可被中断的，要么执行，要么不执行
只有简单的读取、赋值(而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作)才是原子操作
Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性

##### 可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
Java中的可见性，提供了volatile关键字来保证可见性，当一个共享变量被volatile修饰时，他会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候写入主存时不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
通过synchronized和Lock也能保证可见性，synchronized和Loc能保证同一时刻只有一个线程获取锁然后执行同步代码块，并且在释放锁之前会将对变量的修改刷新到主存中，因此可以保证可见性

##### 有序性
即程序执行的顺序按照代码的先后顺序执行。
指令重排序：一般来说处理器为了提高训醒效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
指令重排序不回影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确

Java中的有序性：
在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不回影响到但线程程序的执行，却会影响到多线程并发执行的正确性。
可以通过volatile关键字来保证一定的有序性；synchronized和lock也可保证有序性；另外，Java内存模型具备一些先天的有序性，即不需要通过任何手段就能够得到保证的有序性，这个通常也被称为happens-before原则。如果两个操作的执行次序无法从happens-before原则推到出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序

happens-before(先发生原则)
1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：如果操作A先行发生于操作B，二操作B又线程发生于操作C，则可以得出操作A香型发生于操作C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个动作
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经执行终止
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

##### volatile关键字
1. 保证可见性
一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：
    (1).  保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
    (2). 禁止进行指令重排序
2. volatile不能确保原子性
3. volatile保证有序性
volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性
volatile关键字禁止指令重心排序有两层意思：
   (1). 当程序执行到volatile变量的读操作或者写操作时，在其面前的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
   (2). 在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行

##### volatile实现原理
1. 可见性：处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据读到内部缓存后再进行操作，但操作完后不知神什么时候会写到内存中。

如果对声明了volatile变量进行写操作时，JVM会像处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据

但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理回通过嗅探在总线上传播的数据来检查自己的缓存是否回过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的

2. 有序行：Lock前缀质量实际上相当于一个内存屏障(也叫内存栅栏),它确保指令重排序时不回把后面的指令排到内存屏障之前的位置，也不会把前面的质量排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成

# CAS原子操作
### 乐观锁与悲观锁
##### 悲观锁
在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据)可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，认为一个线程修改共享数据的时候其他线程也会修改该数据，因此只在确保其他线程不回造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。

但是，由于在进程挂起和恢复执行过程中存在着很大的开销，当一个线程正在等待锁时，他不能做任何事，所以悲观锁有很大的缺点

##### 乐观锁
每次不加锁而是假设修改数据之前其他线程一定不回修改，如果因为修改过产生冲突失败就重试，直到成功为止。当数据争用不严重时，乐观锁效果更好，比如CAS就是一种乐观锁思想的应用

### CAS
CAS操作包含三个操作数--内存位置(V)、预期值(A)和新值(B)。执行CAS操作的时候，将内存位置的值与预期值比较，如果相匹配，那么处理器会自动将该位置值更行为新值。否则，处理器不做任何操作
Java中CAS的实现：
1. AtomicBoolean：可以用原子方式更新boolean值
2. AtomicInteger：可以用原子方式更新int值
3. AtomicIntegerArray: 可以用原子方式更新其元素的 int 数组。
4. AtomicIntegerFieldUpdater：基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。
5. AtomicLong：可以用原子方式更新的 long 值。
6. AtomicLongArray：可以用原子方式更新其元素的 long 数组。
7. AtomicLongFieldUpdater：基于反射的实用工具，可以对指定类的指定 volatile long 字段进行原子更新。
8. AtomicMarkableReference：AtomicMarkableReference 维护带有标记位的对象引用，可以原子方式对其进行更新。
9. AtomicReference：可以用原子方式更新的对象引用。
10. AtomicReferenceArray：可以用原子方式更新其元素的对象引用数组。
11. AtomicReferenceFieldUpdater：基于反射的实用工具，可以对指定类的指定 volatile 字段进行原子更新。
12. AtomicStampedReference：AtomicStampedReference 维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。

### CAS的问题
1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却发生了变化。ABA问题的解决思路就是使用版本好。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成1A-2B-3A。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标识是否等于预期标识，如果全部相等，则以原子方式将该引用和该标识的值设置为给定的更新值

2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销

3.只能保证一个共享变量的原子操作。当对一个共享变量执行操作时间，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。 