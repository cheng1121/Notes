# volatile关键字
如果声明一个实例域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程发现并更新的。
## Java内存模型
Java中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此，它存在内存可见性的问题。而局部变量、方法定义的参数则不会在线程之间共享，它们不会有内存可见性的问题，也不受内存模型的影响
- 线程和主存之间的关系：线程之间的共享变量存储在主存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。需要注意的是本地内存是Java内存模型的一个抽象概念，其并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java内存模型控制线程之间的通信，它决定一个线程对主存共享变量的写入何时对另一个线程可见
- 线程A和B之间通信的步骤：
  1. 线程A把线程B本地内存中更新过的共享变量刷新到主存中
  2. 线程B到主存中去读取线程A之前已更新过的共享变量。由此可见，执行线程必须先在自己的工作线程中对变量所在的缓存进行赋值操作，然后在写入主存当中，而不是直接写入主存中
  

## 原子行、可见性和有序性
### 原子性
对基本数据类型变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行完毕，要不就不执行。

一个语句含有多个操作时，就不是原子性操作，只有简单的读取和赋值才是原子性操作

### 可见性
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。

当一个共享变量被volatile修饰时，他会保证修改的值立即被更新到主存，所以对其他线程是可见的。当有其他线程需要读取该值时，其他线程会去主存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，并不会立即被写入主存，何时被写入主存也是不确定的。当其他线程去读取该值时，此时主存中可能还是原来的旧值，这样就无法保证可见性

### 有序性
Java内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，但是会影响到多线程并发执行的正确性。这时可以通过volatile来保证有序性，除了volatile，也可以通过synchronized和Lock来保证有序性。我们知道，synchronized和Lock保证每个时刻只有一个线程执行同步代码，这相当于是让线程顺序执行同步代码，从而保证了有序性

## volatile关键字
volatile有两个作用：
1. 一个是线程修改了变量的值时，变量的新值对其他线程是可见的。换句话说，就是不同线程对这个变量进行操作时具有可见性
2. 禁止使用指令重排序

### 重排序
重排序通常是指编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境

### volatile特点
1. volatile不保证原子性
2. volatile保证可见性
3. volatile保证有序性

### 正确使用volatile关键字
使用volatile的条件：
1. 对变量的写操作不会依赖于当前值，就是不能有自增、自减等操作
2. 该变量没有包含在具有其他变量的不变式中

#### 使用场景
1. 状态标识
```
  volatile boolean shutdown;
        
        public void shutdown(){
            shoutdown = true;
        }
        @Override
        public void run() {
            super.run();
            
            while (!shutdown){
                /* @todo */
            }

        }
```
这里使用volatile，状态标识shutdown并不依赖于程序内的任何其他状态，并且还能简化代码

2. 双重检查模式(DCL)
```
 private volatile static LearnThread instance = null;

    public static LearnThread getInstance() {
        if (instance == null) { //第一次检查，为了不必要的同步
            synchronized (LearnThread.class) {
                if (instance == null) { //只有null时创建实例
                    instance = new LearnThread();
                }
            }
            
        }
        return instance;
    }

```
getInstance方法中进行了两次判空，第一次是为了不必要的同步，第二次是只有在LearnThread等于null的情况下才创建实例。使用volatile关键字会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。

DCL的优点是资源利用率高，第一次执行getInstance方法时单例对象才被实例化，效率高。其缺点是第一次加载时反映稍慢一些，在高并发环境下也有一定的缺陷(发生概率很小)

