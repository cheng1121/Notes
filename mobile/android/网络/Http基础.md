# Http基础

### Http报文
主要分为三部分:
1. 起始行
2. 首部
3. 主体

请求报文格式：
```
<method><request-url><version>
<headers>

<entity-body>
```
响应报文格式：
```
<version><status><reason-phrase>
<headers>

<entity-body>
```
各个标签的含义：

```
<method> 请求方法，常用方法为GET、POST、DELETE等

<version>指协议版本，鲜枣通常都是Http/1.1

<request-url>请求地址

<status> 响应的状态码 有200 404 等

<reason-phrase> 状态码对应的原因
```
### 请求方法method
GET和POST的区别
1. GET请求：参数拼接到url后边，格式为https://www.baidu.com?search=hh&time=now
2. GET请求：Unicode编码的字符都会编码后传输
3. GET请求：http协议未对url长度进行限制，但是一些浏览器和服务器会做限制，所以请参数不能过长
4. GET请求：由于请求参数暴露在地址栏中，所以不够安全 
5. POST请求：将参数放到请求体中，所以不会有GET请求的问题
6. 从语义上来看，GET方法通常是从服务器上获取资源，是读操作；POST请求是进行修改、添加等操作


### 状态码
1. 200: OK 请求成功，实体包含请求的资源
2. 301: Moved Permanent 请求的URL被移除了，通常会在Location首部中包含新的URL用于重定向
3. 304: Not Modified 条件请求进行再验证，资源未改变
4. 404: Not Found 资源不存在
5. 206: Partial Content 成功执行一个部分请求。使用断点续传时会涉及到

### 请求头header
在请求报文和响应报文中都可以携带一些信息，这些信息位于起始行之下与请求实体之间，以键值对的形式，称之为首部(请求头)。每条首部以换行符结尾，最后一个首部额外多一个换行，与实体分隔开

### 实体
请求发送的资源，或者响应返回的资源

### Http缓存
将服务器返回的资源副本存储在本地，当再次对该url资源发起请求时，就能快速的从本地存储设备中获取到该url资源，这就是缓存。既可以节约不必要的网络带宽，又能迅速对http请求做出响应

有以下几个概念：
1. 新鲜度检测：url所对应的资源不是一成不变的，服务器中该url资源可能在一定时间之后会被修改。那么在某个时间之前我们可以认为这个资源没有改变，从而使用缓存资源。**当我们发起一个请求时，需要先对缓存的资源进行判断，看看究竟我们是否可以直接使用该缓存资源，这个就叫做新鲜度检测**
2. 在验证：如果发现缓存资源已经超过了一定的时间，我们再次发起请求时不会直接将缓存资源返回，而是先去服务器查看该资源是否已经改变，这个就叫做再验证
3. 再验证命中：如果服务器发现对应的url资源并没有发生变化，则会返回304 Not Modified，并且不再返回对象对应的实体，这称之为在验证命中。相反如果在验证未命中，则返回200 OK，并将改变后的url资源返回，此时缓存可以更新以待之后请求

##### 具体的实现方式
1. 新鲜度检测：服务器通过在响应报文中增加Cache-Control:max-age,或是Expire这两个首部来实现资源是否超过一定的时间，来判断缓存资源是否新鲜可用。注意：Cach-Control是http1.1的协议规范，通常是相对时间，即多少秒以后，需要结合last-modified这个首部计算出绝对时间；Expire是http1.0的规范，后面接一个绝对时间
2. 再验证：如果通过新鲜度检测发现需要请求服务器进行再验证，那么我们至少需要告诉服务器，我们已经缓存了一个什么样的资源了，然后服务器来判断这个缓存资源到底是不是与当前资源一致。使用**条件请求**的方式实现再验证
3. Http定义了5个首部用于条件请求：
   1. if-Modified-Since
   2. if-None-Match
   3. if-Unmodified-Since
   4. if-Range
   5. if-Match
 
if-Modified-Since结合Last-Modified使用，当我们发起条件请求时，将Last-Modified的值作为if-Modified-Since的值传递到服务器，意思是查询服务器的资源从我们上一次缓存之后是否有修改


if-None-Match需要结合响应首部Etag使用。Etag实际上可以认为是服务器对文档资源定义的一个版本号。有时候一个文档被修改了，可能所做的修改极为微小，并不需要所有的缓存都重新下载数据。或者说某一个文档的修改周期极为频繁，以至于以秒为时间粒度的判断已经无法满足需求。这个时候可能就需要Etag这个首部来表明这个文档的版号了。发起条件请求时可将缓存时保存下来的Etag的值作为if-None-Match首部的值发送至服务器，如果服务器的资源Etag与当前条件请求的Etag一致，表明这次再验证命中


### OAuth
是一个用于授权第三方获取相应资源的协议。与以往的授权方式不同的是，OAuth的授权能避免用户暴露自己的用户密码给第三方，从而更加安全。

OAuth协议通过设置一个授权层，以区分用户和第三方应用。用户本身可以通过用户密码登陆服务提供商，获取到账户所有的资源。而第三方应用只能通过向用户请求收取啊能，获取到一个Access Token，用以登陆授权层，从而在指定时间内获取到用户授权访问的部分资源

OAuth定义了几个角色：
1. Resource Owner：可以授权访问某些受保护资源的实体，通常就是指用户
2. Client：可以通过用户的授权访问受保护资源的应用，也就是第三方应用
3. Authorization server：在认证用户之后给第三方下发Access Token的服务器
4. Resource Service：拥有受保护资源的服务器，可以通过Access Token响应资源请求


OAuth授权的流程：
1. 客户端向用户申请授权
2. 用户同意授权
3. 客户端通过获取的授权，向认证服务器申请Access Token
4. 认证服务器通过授权后,下发Access Token
5. 客户端通过获取到的Access Token向资源服务器发起请求
6. 资源服务器核对Access Token后下发请求资源


### Https
传统的Http协议是一种应用层的传输协议，Http直接与TCP协议通信，其本身存在一些缺点：
1. Http协议使用明文传输，容易遭到窃听
2. Http对于通信双方都没有进行身份验证，通信的双方无法确认对方是否是伪装的客服端或者服务端
3. Http对于传输内容的完整性没有确认的办法，往往容易在传输过程中被劫持篡改

Https相对于Http则可以通过增加的SSL\TLS,支持对于通信内容的加密，以及对通信双方的身份进行验证

##### 加密方式
1. 对称加密：加密与解密过程使用同一把密钥。这种方式的优点是处理速度快，但是如何安全的从一方将密钥传递到通信另一方是一个问题
2. 非对称密钥加密：指加密与解密使用两把不同的密钥。这两把密钥，一把叫公开密钥，可以随意对外公开。一把叫私有密钥，只用于本身持有。客户端使用公开密钥对传输内容进行加密，而只有私有密钥持有者本身可以对公开密钥加密的内容进行解密。这种方式克服了密钥交换的问题，但是相对于对称密钥加密的方式，处理速度较慢
3. SSL\TLS:结合了以上两种加密方式的优点。采用非对称密钥加密，将一个对称密钥使用公开密钥加密后传输到对方。对方使用私有密钥解密，得到传输的对称密钥。之后双方再使用对称密钥进行通信。这样既解决了对称密钥加密的传输问题，又利用了对称密钥的高效率来进行通信内容的加密与解密

##### Https的认证
SSL\TLS加密方式存在一个问题，即怎样确保用于加密的公开密钥确实是所期望的服务器所分发的呢？也许在收到公开密钥时，这个公开密钥已经被别人篡改了。

针对以上问题，目前的做法是使用由数字整数认证机构颁发的公开密钥证书。

向认证机构提出公开密钥申请，认证机构在审核之后，会将公开密钥与公钥证书绑定。服务器就可以将这个公钥证书下发给客户端，客户端在收到证书后，使用认证机构的公开密钥进行验证。一旦验证成功，即可知道这个密钥是可以信任的密钥

##### Https的通信流程
1. Client发起请求
2. Server端响应请求，并在之后将证书发送至Client
3. client使用认证机构的公钥证书，并从证书中取出Server端公钥
4. Client使用公钥加密随机密钥，并传到Server
5. Server使用私钥解密出随机密钥
6. 通信双方使用随机密钥对称密钥进行加密解密
