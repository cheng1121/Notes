### 对象的创建
1. 虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用
2. 检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行响应的类加载过程
3. 在类加载检查成功通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定

### 对象的内存布局
分为3个区域：对象头，实例数据，对齐填充

#### 对象头
包括两部分信息
1. 对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”

2. 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那对象头中还必须有一块用于记录数组长度的数据

#### 实例数据
是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容

#### 对齐填充
对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就要通过对齐填充来补全了

### Java内存区域
1. 方法区(公有)：用于存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。其中包含常量池，用于存放编译器生成的各种字面量和符号引用
2. 堆(公有)：时JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆时垃圾收集器管理的主要区域，因此很多时候也被称为GC堆
3. 虚拟机栈(线程私有)：描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态连接，方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
4. 本地方法栈(线程私有)：与虚拟机栈所发挥的作用类似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务
5. 程序计数器(线程私有)：一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令


### 类加载机制
把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Javaing用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的

#####类的声明周期
加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析3个部分统称为连接
加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。
其中加载、验证、准备、解析、初始化是属于类加载机制中的步骤，注意此时的加载不等同于类加载

#####触发类加载的条件
1. 遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或者设置一个类的静态字段的时候(被final修饰，已在编译器把结果放入常量池的静态字段除外)，以及调用一个类的静态方法的时候
2. 使用java.lang.reflect包的方法对类进行反射调用的时候
3. 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个主类
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发初始化

##### 类加载的具体过程
1. 加载
     (1). 通过一个类的全限定名来获取定义此类的二进制字节流
     (2). 将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构
     (3).在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

2. 验证：是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不回危害虚拟机自身的安全
a. 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
b. 元数据验证：对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息
c. 字节码验证：最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件
d. 符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转为直接引用的时候，这个转换动作将在连接的第三个阶段--解析阶段中发生。符号验证的目的是确保解析动作能正常进行

3. 准备：准备阶段是正式为类变量分配内存并设置变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值通常情况下是数据类型的零值；特殊情况下，如果类字段的字段属性表中存在C onstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值

4. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。
动态解析的含义：必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是静态的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析

5. 初始化：类加载过程的最后一步。初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
<clinit>()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。
简单地说，初始化就是对类变量进行赋值及执行静态代码块。

##### 类加载器分类
1. 启动类加载器(Bootstrap ClassLoader)：由C++语言实现(针对HotSpot)，负责将存放子\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类

2. 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
     扩展类加载器：负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类
    应用程序类加载器：负责加载用户类路径(classpath)上指定类库，通过ClassLoader.getSystemClassLoader()方法获取这个类加载器
    自定义类加载器

##### 双亲委派模型

![image.png](https://upload-images.jianshu.io/upload_images/11142016-76e856f44f4239d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

工作流程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都会被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需要的类时，即无法完成该加载，子加载器才会尝试去自己加载该类

